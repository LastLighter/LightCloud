# 一、遇到的问题
## 1.明明安装了项目依赖，却总是无法引入的问题
原因是没有对应的项目声明文件，在使用ts时，不但需要项目本身，还需要对应的类型声明文件(d.ts),例如我安装`crypto-js`库，我就可以这样安装其类型声明文件。
```shell
npm install --save-dev @types/crypto-js
```
## 2.使用axios时，请求参数放到请求体的问题
实测当使用`put`请求的时候，默认情况下，如果参数被放到`params`属性里，那么最终它不是拼接到路径里，而是被放到请求体中。而get、put等均不会。
## 3.切片上传文件后，后端取回的文件和原来不一致
真的从早干到晚，就为了这一个bug，结果竟然只是切片合并的顺序不一致……
一直以为是元数据没传过去，结果压根没关系，因为元数据就包含在内容里。
之前为了省事，直接用`String`类的`compareTo`方法，但是这种方法不能用于比较数字，因为1永远大于2，后面的字符比较直接失去意义了。
## 4.后端文件无法被删除的问题
其实是因为我们的程序在使用时没有正确地关闭文件流，导致文件仍然被占用。
只要及时关闭它就好了。
## 5.关于后台图片修改后，前端不及时刷新的问题
本质是URL没发生变化，因而前端不知道后台修改了文件。
解决方法，较为简单的是，直接在url后加一个随时间变化的参数，这样url不一致，浏览器就重新请求资源。
```ts
useUserInfoStore().avatarURL = temp + '?' + String(new Date().getTime())
```
## 6.关于输入表单的一些坑
一般用于账号密码的，需要添加`autocomplete`字段，这样浏览器会默认填充，虽然你不加原则上也会填充。
这个填充功能非常坑人，当用户填充的时候，这个input表单的部分样式还会被重写（例如背景），我原本用了个透明背景，强行给我加了个白色（整无语了），导致显示效果出现问题，而且css也没法纠正它。
但是你删掉它的自动填充内容，背景css效果就会恢复正常。
## 7.使用迭代器的坑，不能使用时修改元素
前端`forEach`中的item只是一个迭代的临时变量，修改它无效，但是可以操控本体利用for循环来修改。
而在后端Java里面，使用增强for循环迭代时修改内容会直接报出错误，因其内容发生变化。具体错误信息如下：
> class java.util.ConcurrentModificationException:null
## 8.后端删除文件的一些坑
当用户删除文件时，我们并不能直接把文件删除，因为要考虑到秒传和复制的存在，用户在上传文件时，可能一份本地文件对应多份数据库的记录，如果我们直接删除，那么其他用户也无法再下载文件。因而我们在删除时要查询是否存在同一地址的多个引用，确保安全后才能删除。
## 9.后端并发更新数据的一些坑
我是同时删除文件时遇到的，明明单个删除没问题，同时一删就出现用户空间的数据错误的情况。
其本质是并发请求时数据的读写存在覆盖问题。
解决思路有三：
### 9.1利用update语句的原子性
sql中的`update`是原子的，这意味着不会有两个`update`同时执行。
我们可以直接这样写,这样一来，我们不负责读取，写入也交给sql，就不会出现并发的数据错误。
```sql
UPDATE user SET `user_space`= user_space - #{offset} WHERE `uid`=#{uid}
```
### 9.2乐观锁机制（特点是积极尝试，一次不成就继续）
乐观锁机制的实现是在数据库和`entity`中加入一个`version字段`（每次更改都修改这个字段），通过这个字段，我们在事务中读取时获取这个字段，在写入时sql条件通过`WHERE`限制其必须与读取时得到的一致（说明这期间没有被更改），否则执行失败，失败后我们在异常处理中选择重试，直至执行成功。
其缺点在于，要维护一个额外的字段，并且在高并发的场景下，容易事务导致迟迟无法等来修改的机会，最终空转cpu。
### 9.3悲观锁机制
悲观锁的思路是，进行任何读写操作都必须加锁。这里锁可以分为两种，共享锁（可允许多个人读）和排他锁（只允许一个人写），这两种锁一个数据身上不能同时持有（不然就可能出现脏数据，你读的时候我就改了，但你又不知道）。根据锁的位置，可以分为数据库级别和应用程序集别。一般我们使用数据库级别的锁更多一些。  
#### 9.3.1 mysql的行级锁
数据库可以在任意sql后面加上`FOR SHARE`语句来添加共享锁，`FOR UPDATE`来添加排他锁。
这些锁都是行级的，意味着其他行数据不会受到影响。当使用共享锁时，可以允许多个事务同时读取一行数据，不管其他sql语句有没有带上锁。使用排他锁时，只允许有一个事务持有这个锁，进行操作。
请注意sql语句中，只有`SELECT`能够加锁，因为只有它加锁被认为是有意义的，update语句本身即是原子性的，不用担心同时被执行。
```sql
SELECT * FROM user WHERE id = #{id} FOR SHARE
SELECT * FROM user WHERE id = #{id} FOR UPDATE
```
# 二、编码过程
## 1.创建项目
我通过`npm create vue@latest`命令创建了一个`vite + vue3`的项目。
然后使用`npm install` 命令安装了项目依赖，最终通过`npm run dev`确保了项目能正常运行。
## 2.代理服务器配置
vite.config.ts文件
```ts
server: {
    port: 666,
    hmr: true,
    proxy: {
      '/api': {
        target: 'http://lightcloud.io',
        changeOrigin: true,

        //路径重写不能要，因为api文档里需要带路径
        // rewrite: (path) => path.replace(/^\/api/, ''),
      }
    }
  }
```
## 3.清除默认的浏览器样式
复制了之前的`reset.css`文件放到asset中，然后在`main.ts`中引入。
```ts
import './assets/reset.css'
```
## 4.配置路由
如下
```ts
import { createRouter, createWebHistory } from 'vue-router'
import HomeView from '../views/HomeView.vue'

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: [
    {
      path: '/',
      name: 'home',
      component: HomeView
    },
    {
      path: '/login',
      name: 'login',
      // route level code-splitting
      // this generates a separate chunk (About.[hash].js) for this route
      // which is lazy-loaded when the route is visited.
      component: () => import('../views/LoginView.vue')
    }
  ]
})

export default router
```
## 5.封装request对象
我这里使用了`axios`来处理网络请求,于是我新建了一个util目录，然后放入该文件。
```ts
//对Axios进行二次封装，目的是？
//代码复用，利用axios的请求和响应拦截器功能
//请求拦截器一般可以在请求头中携带公共的参数：token
//响应拦截器可以简化服务器返回的数据，处理http网络错误
//便于更换网络库，例如axios停止维护，可以方便的更换。

import axios from "axios";

//创建自定义的axios对象
const request = axios.create({
    baseURL: '/api',//请求的基本路径，所有请求都会带上
    timeout: 5000//超时时间
})

//请求拦截器
request.interceptors.request.use((config) => {
    //config是一个配置对象，可以用来配置重要的headers属性

    return config
})

//响应拦截器
request.interceptors.response.use((response) => {
    return response.data
},(error) => {
    console.log(error);
    
    ElMessage({
        type: 'error',
        message: error.message
    })
})

//导出自定义的axios
export default request;
```

## 6.封装登录使用的类型
我认为这个复制粘贴的过程过于麻烦，以后有时间自己开发一个`java bean -> ts interface`转换器。
这些就放到`api/common/type.ts`下吧。
```ts
export interface userInfo {
    uid: number,
    nickName: string,
    email: string,
    avatarName: string,
    createTime: string,
    lastLoginTime: string,
    status: number,
    userSpace: string,
    totalSpace: string
}

export interface LoginData {
    email: string,
    password: string,
    code: string,
    codeKey: string,
}
```
## 7.设计登录界面
### 7.1取消input的默认显示效果
由于我们需要高度定制化样式，因此取消这个效果是很关键的。
方法如下：
```css
input:focus{
  outline: none;
}
```
### 7.2验证码图片的显示
由于这里使用的是base64.因此步骤较为简单。
通过`img`标签拼接内容展示即可，如下所示：
```html
<img :src="'data:image/jpeg;base64,' + codeRes.value">
```
但是由于是异步请求，所以还是得做v-if处理。
### 7.3登录pinia的store处理
要处理如此多的登录信息，比较方便的写法就是通过pinia，因为pinia能在多组件之间灵活通信。
```ts
import { ref, computed } from 'vue'
import { defineStore } from 'pinia'

export const useUserInfoStore = defineStore('userInfo', () => {
  let email = ref<string>()

  return { email }
})
```
## 8.主页的设计
### 8.1前端计算File的md5值
根据gpt的答案，我们可以使用`crypto-js`这个库,没太多技术含量，封装一个异步方法来用，代码贴下面：
```ts
let calcMd5 = (file: File) => {
    return new Promise<string>((resolve, rejects) => {
        const fileReader = new FileReader();

        fileReader.onload = (event) => {
            const arrBuffer = event.target?.result
            const wordArr = CryptoJS.lib.WordArray.create(arrBuffer as ArrayBuffer)
            const md5 = CryptoJS.MD5(wordArr).toString()
            resolve(md5)
        }

        fileReader.onerror = (error) => {
            rejects(error)
        }

        fileReader.readAsArrayBuffer(file)
    })
}
```
### 8.2文件切片上传
搞了一整天才搞好（都搞到早上了才解决），不是前端就是后端出毛病。
思路如下：  
#### （1）通过input标签来获取用户选择的文件
给input元素设置`change`事件，这样用户选择文件时就会触发，当然也有个坑，一直选择一个文件就麻烦了。
```ts
const target = event?.target as HTMLInputElement
    let files = target?.files
```
#### (2)给文件切片
这个不是很麻烦，因为ts里已经有对应的函数了。
把思路捋清楚就行。
```ts
let sliceFile = (file: File, chunkSize: number) => {
    const totalChunk = Math.ceil(file.size / chunkSize);
    console.log('totalChunk:',totalChunk);
    let chunks: Blob[] = []
    for (let i = 0; i < totalChunk; ++i) {
        const start = i * chunkSize
        const end = Math.min(start + chunkSize, file.size)
        
        const slicedBlob = file.slice(start, end);
        //这里重新设置其mime信息，以方便后端识别
        let chunk = new Blob([slicedBlob], { type: file.type });
        
        chunks.push(chunk)
    }
    return chunks
}
```
#### （3）通过表单数据（form-data）的形式上传文件
这个困扰了我好久，因为一直搞不清楚该怎么上传才是对的。
包括后端该怎么接收这样的格式，一边问gpt，然后试了不知道多少次。
当然第一次写，后端上传这块也是一堆bug，改了很久……
这里有个小坑，就是我们需要在一个切片传输失败之后，不再继续传输。
因此选用`try catch`是最好的解法。
```ts
for (let i = 0; i < files.length; i++) {
        let md5 = await calcMd5(files[i])
        let chunks = sliceFile(files[i], 100 * KB)
        let fileId = ''
        for (let j = 0; j < chunks.length; ++j) {
            const formData = new FormData()
            formData.append('fileId', fileId)
            formData.append('fileParentId', fileParent)
            formData.append('md5', md5)
            formData.append('token', token)
            formData.append('chunkIndex', String(j))
            formData.append('chunkNum', String(chunks.length))
            formData.append('file', chunks[j])

            //send
            try {
                let resDto = await uploadFile(formData)
                fileId = resDto?.fileId

                if(resDto.fileId == undefined){
                    break
                }
            } catch (error) {
                break
            }
        }
    }
```
# 三、学到的知识点
## 1.可选链
有时我们想要访问一个对象的属性，但这个对象可能并不存在这个属性，或者内容为null。
这时候我们可以使用`可选链（Optional Chaining）`，如下所示：
```ts
codeKey.value = codeRes.value?.key
```
如果这个被访问的对象不存在`value`这一属性（内容为null或undefined）,则不会继续访问key,直接返回`undefined`,不会导致程序出错。
这个可选链还可以链式使用，如果我们每一步都需要谨慎确定当前对象是否能被访问（即当前对象是否为null或undefined），就可以链式使用。
```ts
codeKey.value = codeRes?.value?.key
```
## 2.逻辑或操作符
常用于处理表达式的错误情况下返回值（即`falsy`），
这个`falsy`包括`undefined`、`null`、`false`、`0`、`NaN`或`空字符串`。
例如：
```ts
codeRes.value?.key || ''
```
当左边的表达式返回值为`falsy`时，就会返回右边的空字符串
## 3.flex盒子模型与padding的布局小坑
当我们使用盒子模型的时候，如果同时使用了padding，那么浏览器会先计算padding，然后
盒子模型才会在padding的剩余空间基础上进行计算。因此很容易出现一种情况，设置`justify-content: space-between;`时，右边的元素如果宽度小于padding的左边距，就很容易划出屏幕外“消失”。
## 4.盒子模型“子元素margin被父元素抢走”的坑
今天就遇到了这种情况，只能说非常之离谱。
具体是这样的，三级`div`（简称爷、父、子）嵌套，给子元素设置了一个`margin-top`，
父元素在爷元素中就不会靠顶对齐，而是抢了子元素的`margin-top`。
而且浏览器调试无法看出异样。
其解决思路很简单，就是给父元素设置一个`padding`，让子元素不靠上父元素的顶，这样不会发生问题,据说这是因为父子元素边距一致，上下文发生冲突所致，因此我们设置一个不为0的值，父元素就抢不走子元素的`margin`。
当然也可以换一种思路，就是我们想要多个同列元素边距时，不再设置`margin-top`,而是直接设置`margin-bottom`,这样一来，即使在盒子的`top`边缘处父子元素的边距发生冲突，也无法抢走`bottom`的属性
## 5.解决“点击页面其他区域时，右键菜单消失”的需求
比较合适的方案是，给`document`元素绑定`click`事件,一旦用户触发点击，就判断该点击事件是否位于指定的dom区域，如果不在指定区域，则说明应该使`context`组件消失。
参考代码如下：
```ts
//监听是否点击了组件之外的地方（以便消除右键菜单）
onMounted(() => {
    document.addEventListener('click', handleGlobalClick)
})
//模板引用，获取指定元素
let contextMenu = ref<HTMLDivElement | null>(null)
let handleGlobalClick = (event: MouseEvent) => {
    if (contextMenu.value != null && !contextMenu.value.contains(event.target as Node)) {
        commonStore.contextMenuShow = false
    }
}
```
## 6.后端ServletOutputStream本身是缓冲流
因而我们在使用它返回文件的时候，不需要再包装一层`BufferedOutputStream`。
而且在使用它上传的时候，每隔一段文件调用`flush()`方法，就能实现断点上传的功能。
## 7.js的number类型不精确问题
我们都知道，js的number类型表示一些很大的整数时会出现不精确的情况，
它会取最近的数字来表示，这种情况对于需要精确计算的场景十分危险（例如分片下载，大数计算）。
我们可以采取的方式是换用`bigint`类型来代替，它可以表示的范围更加广阔。
定义的方式也很简单。
```ts
let chunkSize:bigint = 2n * 1024n * 1024n
```
## 8.使用正则表达式来提取字符串信息
这是一种比较方便的做法，当字符串内容比较复杂时较为好用。
从性能上来说可能不是最优解，但是对于非大规模使用的情况下，仍然是一种很好的方法。
例如我要从字符串`attachment;filename="example.pdf"`中提取出文件名`example.pdf`
```ts
const str = 'attachment;filename="example.pdf"';
const regex = /filename="([^"]+)"/;
const match = str.match(regex);

if (match && match[1]) {
    const filename = match[1];
    console.log(filename);
} else {
    console.log('未能找到文件名');
}
```
以下是`ChatGpt`对于这段代码的解释：
> 当我们使用正则表达式来匹配字符串时，我们首先定义了一个模式，也就是 filename="([^"]+)"。这个模式表示我们要匹配的内容应该是以 filename=" 开头，然后是任意数量的非双引号字符，最后以 " 结尾。

> 接着我们使用 match 方法来在给定的字符串中搜索匹配该模式的部分。如果找到了匹配的内容，match 方法会返回一个数组，其中第一个元素是整个匹配的字符串，随后的元素则是模式中用括号括起来的子模式所匹配到的内容。

> 在这段代码中，我们使用 match[1] 来获取第一个子模式匹配到的内容，也就是文件名。如果找到了匹配的文件名，那么将其输出到控制台；如果没有找到匹配的内容，则输出 "未能找到文件名"。

> 这种方法可以帮助我们从特定格式的字符串中提取出我们需要的内容，而且通过调整正则表达式的模式，我们可以适应不同的格式要求。
## 9.使用axios获取响应头
默认当我们调用`axios.get()`来请求资源时，得到的是一个`AxiosResponse`对象，
我们可以通过其`header`属性来获取其响应头内容。但是注意，其中的响应头的`key`全都是小写。
也就是说，如果我们用大写来读取，是读不到想要的字段值的。这里需要注意。
```ts
let res = await download(fid, uid, start, start + chunkSize)  
fileSize = res.headers['content-range'].split('/')[1];
```
## 10.axois下载文件
样例代码如下，我采用的是分片下载,将临时文件以Blob的形式保存到本地，这样可以减少服务器拥塞带来的压力，而且可以随时中断。但是这种方式不适合下载大型文件，原因是浏览器分配给页面的资源是有限的，如果文件过大，就会造成卡顿。而要下载一个大型文件，比较合适的思路是使用fetch通过流来下载，这样文件不会大量占据浏览器分配的资源，而是边下边存到本地中，压力大大减小。
```ts
export const download = async(fid:string, uid:bigint, start: bigint, end: bigint) => {
    const config = {
        headers: {
            Range: `bytes=${start}-${end}`,
        },
        //不设置的话，默认会被以json格式解析，会导致得到的是string类型
        responseType: 'arraybuffer'
    };
    let res:AxiosResponse<ArrayBuffer> = await axios.get<any,AxiosResponse<ArrayBuffer>>(`/api/file/download/${fid}?uid=${uid}`, config)
    return res
}

export const sliceDownloadFile = async (fid: string, uid: bigint) => {
    let commonStore = useCommonStore()
    let chunkSize: bigint = 2n * 1024n * 1024n
    let start: bigint = 0n
    let fileSize: bigint = chunkSize
    let fileName = ''
    let arrs: ArrayBuffer[] = []
    while (start < fileSize) {
        let res = await download(fid, uid, start, start + chunkSize)
        fileSize = res.headers['content-range'].split('/')[1];
        let disposition: string = res.headers['content-disposition']
        fileName = decodeURIComponent(getFileName(disposition))
        start += chunkSize
        arrs.push(res.data)
        console.log('res:', res.data);
        
        console.log('byte:', res.data.byteLength);
    }
   
    console.log(arrs);
    
    
    let file = new Blob(arrs, { type: 'application/octet-stream' })
    // 创建一个 URL，用于生成下载链接
    const url = URL.createObjectURL(file);

    // 创建一个 <a> 元素
    const link = document.createElement('a');
    link.href = url;
    link.download = fileName;

    // 将 <a> 元素添加到 DOM 中
    document.body.appendChild(link);

    // 模拟用户点击下载链接
    link.click();

    // 清理创建的 URL
    URL.revokeObjectURL(url);

    //清除正在下载的状态
    commonStore.curDownloadFile = null
}

let getFileName = (disposition: string) => {
    const regex = /filename="([^"]+)"/;
    const match = disposition.match(regex);
    let filename = ''

    if (match && match[1]) {
        filename = match[1];
    } 
    return filename
}
```

## 11.解决ToolTip提示框到屏幕边缘时，内容被阻挡的问题
其实思路上很简单，就是让靠近窗口边缘时改变其位置即可，例如我设置了一个`offset`,一旦与窗口的距离小于这个值，就会在鼠标位置的基础上减去这个offset，从而使其内容不溢出box。这个offset最好的值是与你的`ToolTip`宽高相同。
```ts
let edgeOffsetX = 280
let edgeOffsetY = 120
let mouseoverHandler = (event: MouseEvent) => {
    tipShow.value = true

    if(event.clientX < window.innerWidth - edgeOffsetX){
        leftPoi.value = event.clientX
    }else {
        leftPoi.value = event.clientX - edgeOffsetX
    }
    if(event.clientY < window.innerHeight - edgeOffsetY){
        topPoi.value = event.clientY
    }else {
        topPoi.value = event.clientY - edgeOffsetY
    }
}
```
## 12.通过js动态获取当前url、域名、端口号等信息
可以直接通过`window.location`对象的属性来实现,具体如下：
```js
window.location.href：完整的URL字符串。
window.location.protocol：URL的协议部分，例如'https:'。
window.location.host：包含主机名和端口号（如果指定了端口）的字符串，例如'www.example.com:80'。
window.location.hostname：仅主机名，例如'www.example.com'。
window.location.port：端口号（如果有的话），例如'80'。
window.location.pathname：URL中主机名之后的部分，例如'/products/list'。
window.location.search：URL的查询字符串部分，以?开头，例如'?query=search'。
window.location.hash：URL的片段标识符部分，以#开头，例如'#section1'。
```
## 13.v-model 可以根据不同的表单元素类型，自动绑定相应的属性，并实现双向数据绑定。
例如，对于以下代码：
```html
<input type="text" v-model="message">
```
上述代码中，v-model 绑定了 `<input>` 元素的 value 属性，而 message 就是 Vue 组件中的一个数据属性。当用户在输入框中输入内容时，message 的值会自动更新为输入框中的值。

对于`<select>` 元素，v-model 绑定的是 value 属性。而对于 `<checkbox>` 和 `<radio>` 元素，v-model 绑定的是 checked 属性。

需要注意的是，当使用 v-model 绑定表单元素时，还可以通过设置 v-bind:value 和 v-on:input 来手动控制绑定的属性和事件。

综上所述，v-model 可以根据不同的表单元素类型，自动绑定相应的属性，并实现双向数据绑定。
## 14.关于组件Props的使用
一般由于`props`单向数据流、带有响应式的特性，我们会使用`computed`来计算它，这样做的好处是完美解决自动更新问题，computed本身是响应式的，用它的话不需要定义新的ref，也不需要用`watch`来监听`props`的响应式。

